{"version":3,"sources":["../../src/api/tags.js"],"names":["AUTO_TAG_TYPE","SOURCE_TAG_TYPE","MANUAL_TAG_TYPE","generateTagId","indexName","fileId","tagType","tagName","getSha256","trim","toLowerCase","config","storage","api","get","ensureAuthenticated","req","res","next","email","extractEmailFromHeaders","getUserIndex","getTags","redis","elasticSearch","then","status","json","tags","catch","post","params","type","tagId","tag","id","name","addTag","delete","removeTag","ensureAuthenticatedAsService","sendStatus","getTaggingRules","mongoDb","rules"],"mappings":"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","file":"tags.js","sourcesContent":["import { Router } from 'express'\nimport ErrorResponse from '../utils/ErrorResponse'\nimport {\n    CryptoService,\n    EsProxy,\n    MongoProxy,\n    CacheProxy,\n    DateTimeService,\n    AuthService\n} from '../services'\n\nconst AUTO_TAG_TYPE = 'auto'\nconst SOURCE_TAG_TYPE = 'source'\nconst MANUAL_TAG_TYPE = 'manual'\n\nconst generateTagId = (indexName, fileId, tagType, tagName) => {\n    return CryptoService.getSha256(`tag_${indexName.trim().toLowerCase()}${fileId.trim().toLowerCase()}${tagType.trim().toLowerCase()}${tagName.trim().toLowerCase()}`)\n}\n\nexport default ({ config, storage }) => {\n    let api = Router()\n\n    //////////////// CALLED FROM UI ////////////////////////////////////\n    /**     \n     * @api {get} api/tags/ Get Tags \n     * @apiGroup Tags                \n     *  \n     * @apiHeader {String} ambar-email User email\n     * @apiHeader {String} ambar-email-token User token\n     * \n     * \n     * @apiSuccessExample HTTP/1.1 200 OK     \n[  \n      {  \n         \"name\":\"ocr\",\n         \"filesCount\":3\n      },\n      {  \n         \"name\":\"test\",\n         \"filesCount\":2\n      },\n      {  \n         \"name\":\"pdf\",\n         \"filesCount\":1\n      }\n]\n     * \n     */\n    api.get('/', AuthService.ensureAuthenticated(storage), (req, res, next) => {\n        const email = AuthService.extractEmailFromHeaders(req)\n        const indexName = AuthService.getUserIndex(email)\n\n        CacheProxy.getTags(storage.redis, storage.elasticSearch, indexName)\n            .then(tags => {\n                res.status(200).json(tags)\n            })\n            .catch(next)\n    })\n\n    /**     \n        * @api {post} api/tags/:fileId/:tagType/:tagName Add Tag For File   \n        * @apiGroup Tags                \n        *  \n        * @apiHeader {String} ambar-email User email\n        * @apiHeader {String} ambar-email-token User token\n        * \n        * @apiParam {String} fileId     File Id to add tag to.\n        * @apiParam {String} tagType    Tag type to add.\n        * @apiParam {String} tagName    Tag name to add.\n        * \n        * @apiSuccessExample HTTP/1.1 200 OK     \n   {  \n      \"tagId\":\"e9536a83e64ff03617ab0379d835ac7bbf213bafb95cb42907a56e735472d4fc\",\n      \"tags\":[  \n         {  \n            \"name\":\"ocr\",\n            \"filesCount\":3\n         },\n         {  \n            \"name\":\"test\",\n            \"filesCount\":2\n         },\n         {  \n            \"name\":\"pdf\",\n            \"filesCount\":1\n         }\n      ]\n   }\n        * \n        */\n    api.post('/:fileId/:tagType/:tagName', AuthService.ensureAuthenticated(storage), (req, res, next) => {\n        const { params: { fileId, tagType, tagName } } = req\n\n        if (!tagName || !fileId || !tagType || tagType.toLowerCase() != MANUAL_TAG_TYPE) {\n            res.status(400).json(new ErrorResponse('Required field is missing'))\n            return\n        }\n\n        const email = AuthService.extractEmailFromHeaders(req)\n        const indexName = AuthService.getUserIndex(email)\n        const type = tagType.toLowerCase()\n        const tagId = generateTagId(indexName, fileId, type, tagName)\n\n        const tag = {\n            id: tagId,\n            type: type.toLowerCase(),\n            name: tagName.trim().toLowerCase()\n        }\n\n        CacheProxy.addTag(storage.redis, storage.elasticSearch, indexName, fileId, tag)\n            .then(tags => {\n                res.status(200).json({ tagId: tagId, tags: tags })\n            })\n            .catch(next)\n    })\n\n    /**     \n      * @api {delete} api/tags/:fileId/:tagType/:tagName Delete Tag From File   \n      * @apiGroup Tags                \n      *  \n      * @apiHeader {String} ambar-email User email\n      * @apiHeader {String} ambar-email-token User token\n      * \n      * @apiParam {String} fileId     File Id to delete tag from.\n      * @apiParam {String} tagType    Tag type to delete.\n      * @apiParam {String} tagName    Tag name to delete.\n      * \n      * @apiSuccessExample HTTP/1.1 200 OK     \n {  \n    \"tags\":[  \n        {  \n          \"name\":\"ocr\",\n          \"filesCount\":3\n       },\n       {  \n          \"name\":\"test\",\n          \"filesCount\":2\n       },\n       {  \n          \"name\":\"pdf\",\n          \"filesCount\":1\n       }\n    ]\n }   \n      * \n      */\n    api.delete('/:fileId/:tagType/:tagName', AuthService.ensureAuthenticated(storage), (req, res, next) => {\n        const { params: { fileId, tagType, tagName } } = req\n\n        if (!fileId || !tagName || !tagType) {\n            res.status(400).json(new ErrorResponse('Required field is missing'))\n            return\n        }\n\n        const email = AuthService.extractEmailFromHeaders(req)\n        const indexName = AuthService.getUserIndex(email)\n        const type = tagType.toLowerCase()\n        const tagId = generateTagId(indexName, fileId, type, tagName)\n\n        const tag = {\n            id: tagId,\n            type: type.toLowerCase(),\n            name: tagName.trim().toLowerCase()\n        }\n\n        CacheProxy.removeTag(storage.redis, storage.elasticSearch, indexName, fileId, tag)\n            .then(tags => {\n                res.status(200).json({ tags: tags })\n            })\n            .catch(next)\n    })\n\n    //////////////// CALLED FROM PIPELINE ////////////////////////////////////\n    /**\n    * Add tag for specified file id\n    */\n    api.post('/service/:indexName/:fileId/:tagType/:tagName', AuthService.ensureAuthenticatedAsService(storage), (req, res, next) => {\n        const { params: { fileId, indexName, tagName, tagType } } = req\n\n        if (!tagName || !fileId || !indexName || !tagType || ((tagType.toLowerCase() != AUTO_TAG_TYPE) && (tagType.toLowerCase() != SOURCE_TAG_TYPE))) {\n            res.status(400).json(new ErrorResponse('Required field is missing'))\n            return\n        }\n\n        const type = tagType.toLowerCase()\n        const tagId = generateTagId(indexName, fileId, type, tagName)\n\n        const tag = {\n            id: tagId,\n            type: type,\n            name: tagName.toLowerCase()\n        }\n\n        CacheProxy.addTag(storage.redis, storage.elasticSearch, indexName, fileId, tag)\n            .then(tags => {\n                res.sendStatus(200)\n            })\n            .catch(next)\n    })\n\n    /**\n    * Get tagging rules\n    */\n    api.get('/service/taggingrules', AuthService.ensureAuthenticatedAsService(storage), (req, res, next) => {\n        MongoProxy.getTaggingRules(storage.mongoDb)\n            .then(rules => {\n                res.status(200).json(rules)\n            })\n            .catch(next)\n    })\n\n    return api\n}"]}