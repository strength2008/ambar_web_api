{"version":3,"sources":["../../src/utils/SliceBuffer.js"],"names":["SliceBuffer","startBytesToPass","endBytesToPass","m","Math","max","tempBuffer","Buffer","alloc","prevBuffer","isFirst","chunk","enc","cb","byteLength","push","isBuffer","Error","concat","slice","from"],"mappings":";AACA,gC;;AAEMA,W;;;;;;;;AAQF,yBAAYC,gBAAZ,EAAsCC,cAAtC,EAA8D;;AAE1D,cAAKD,gBAAL,GAAwBA,gBAAxB;AACA,cAAKC,cAAL,GAAsBA,cAAtB;;AAEA,cAAKC,CAAL,GAASC,KAAKC,GAAL,CAAS,MAAKJ,gBAAd,EAAgC,MAAKC,cAArC,CAAT;;AAEA,cAAKI,UAAL,GAAkBC,OAAOC,KAAP,CAAa,CAAb,CAAlB;AACA,cAAKC,UAAL,GAAkBF,OAAOC,KAAP,CAAa,CAAb,CAAlB;AACA,cAAKE,OAAL,GAAe,IAAf,CAT0D;AAU7D,K;;AAEUC,a,EAAeC,G,EAAaC,E,EAAc;;AAEjD,gBAAIN,OAAOO,UAAP,CAAkB,KAAKL,UAAvB,IAAqC,CAAzC,EAA4C;AACxC,qBAAKM,IAAL,CAAU,KAAKN,UAAf;AACH;;AAED,gBAAI,CAACF,OAAOS,QAAP,CAAgBL,KAAhB,CAAL,EAA6B;AACzB,sBAAM,IAAIM,KAAJ,CAAU,qBAAV,CAAN;AACH;;AAED,gBAAIV,OAAOO,UAAP,CAAkB,KAAKR,UAAvB,IAAqC,KAAKH,CAA9C,EAAiD;AAC7C,qBAAKG,UAAL,GAAkBC,OAAOW,MAAP,CAAc,CAAC,KAAKZ,UAAN,EAAkBK,KAAlB,CAAd,CAAlB;AACH,aAFD,MAEO;AACH,oBAAI,KAAKD,OAAT,EAAkB;AACd,yBAAKJ,UAAL,GAAkB,KAAKA,UAAL,CAAgBa,KAAhB,CAAsB,KAAKlB,gBAA3B,CAAlB;AACA,yBAAKS,OAAL,GAAe,KAAf;AACH;;AAED,qBAAKD,UAAL,GAAkBF,OAAOa,IAAP,CAAY,KAAKd,UAAjB,CAAlB;AACA,qBAAKA,UAAL,GAAkBC,OAAOa,IAAP,CAAYT,KAAZ,CAAlB;AACH;;AAEDE;AACH,S;;AAEMA,U,EAAc;AAClB,iBAAKE,IAAL,CAAU,KAAKN,UAAf;AACA,iBAAKH,UAAL,GAAkB,KAAKA,UAAL,CAAgBa,KAAhB,CAAsB,CAAtB,EAAyBZ,OAAOO,UAAP,CAAkB,KAAKR,UAAvB,IAAqC,KAAKJ,cAAnE,CAAlB;AACA,iBAAKa,IAAL,CAAU,KAAKT,UAAf;;AAEAO;AACF,S;;;AAGUb,W","file":"SliceBuffer.js","sourcesContent":["\nimport {Transform} from 'stream'\n\nclass SliceBuffer extends Transform {\n    startBytesToPass: number;\n    endBytesToPass: number;\n    tempBuffer: Buffer;\n    prevBuffer: Buffer;\n    isFirst: bool;\n    m: number;\n\n    constructor(startBytesToPass: number, endBytesToPass: number) {        \n        super()\n        this.startBytesToPass = startBytesToPass\n        this.endBytesToPass = endBytesToPass\n\n        this.m = Math.max(this.startBytesToPass, this.endBytesToPass)\n\n        this.tempBuffer = Buffer.alloc(0)     \n        this.prevBuffer = Buffer.alloc(0)\n        this.isFirst = true   \n    }\n\n    _transform(chunk: Object, enc: string, cb: Function) {\n        \n        if (Buffer.byteLength(this.prevBuffer) > 0) {\n            this.push(this.prevBuffer)\n        }\n\n        if (!Buffer.isBuffer(chunk)) {\n            throw new Error('Chunk is not Buffer')\n        }        \n\n        if (Buffer.byteLength(this.tempBuffer) < this.m) {\n            this.tempBuffer = Buffer.concat([this.tempBuffer, chunk])\n        } else {\n            if (this.isFirst) {\n                this.tempBuffer = this.tempBuffer.slice(this.startBytesToPass)\n                this.isFirst = false\n            }\n\n            this.prevBuffer = Buffer.from(this.tempBuffer)\n            this.tempBuffer = Buffer.from(chunk)\n        }\n\n        cb()\n    }\n\n    _flush(cb: Function) {        \n       this.push(this.prevBuffer)\n       this.tempBuffer = this.tempBuffer.slice(0, Buffer.byteLength(this.tempBuffer) - this.endBytesToPass)\n       this.push(this.tempBuffer) \n\n       cb()\n    }\n}\n\nexport default SliceBuffer"]}