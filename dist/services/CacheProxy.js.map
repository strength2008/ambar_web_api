{"version":3,"sources":["../../src/services/CacheProxy.js"],"names":["checkIfMetaIdExists","redis","indexName","metaId","getAsync","addMetaId","set","getCurrentDateTime","checkIfTokenExists","token","addToken","ttlSeconds","expire","removeToken","del","addServiceToken","CONTENT_SETTINGS_EXPIRATION_SECONDS","getEsIndexContentSize","elasticSearch","Promise","resolve","reject","then","res","parseInt","getShortStats","indexSize","stats","aggregations","proc_total","sum","catch","err","setEsIndexContentSize","size","removeEsIndexContentSize","getEsIndexContentMaxSize","mongo","getUserByIndexName","user","storage_max","Error","setEsIndexContentMaxSize","removeEsIndexContentMaxSize","getCurrentCrawlerTask","crawlerName","setCurrentCrawlerTask","taskUid","addTag","fileId","tag","indexTag","esResult","hasTagsInRedis","hasTags","result","getTagFilesCount","name","type","setTagFilesCount","filesCount","getTags","tags","removeTag","deleteTag","id","transformTagsStat","redisResp","Object","keys","map","tagName","split","sort","tagA","tagB","existsAsync","tagType","hgetAsync","hdel","hset","setTagsFromEs","hgetallAsync","redisResult","getTagsStat","length","tagsArray","idx","forEach","hmset"],"mappings":"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","file":"CacheProxy.js","sourcesContent":["import { EsProxy, MongoProxy, DateTimeService, CryptoService } from './index'\n\nexport const checkIfMetaIdExists = (redis, indexName, metaId) => redis.getAsync(`meta:${indexName}${metaId}`)\nexport const addMetaId = (redis, indexName, metaId) => { redis.set(`meta:${indexName}${metaId}`, DateTimeService.getCurrentDateTime()) }\n\nexport const checkIfTokenExists = (redis, token) => redis.getAsync(token)\nexport const addToken = (redis, token, ttlSeconds) => {\n    redis.set(token, DateTimeService.getCurrentDateTime())\n    redis.expire(token, ttlSeconds)\n}\nexport const removeToken = (redis, token) => {\n    redis.del(token)\n}\nexport const addServiceToken = (redis, token) => {\n    redis.set(token, DateTimeService.getCurrentDateTime())\n}\n\nconst CONTENT_SETTINGS_EXPIRATION_SECONDS = 10 * 60\n\nexport const getEsIndexContentSize = (redis, elasticSearch, indexName) => new Promise((resolve, reject) => {\n    redis.getAsync(`size:${indexName}`)\n        .then(res => {\n            if (res) {\n                resolve(parseInt(res))\n                return\n            }\n\n            return EsProxy.getShortStats(elasticSearch, indexName)\n                .then(stats => {\n                    const indexSize = stats.aggregations\n                        ? stats.aggregations.proc_total\n                            ? stats.aggregations.proc_total.sum\n                                ? stats.aggregations.proc_total.sum\n                                : 0\n                            : 0\n                        : 0\n                    redis.set(`size:${indexName}`, indexSize)\n                    resolve(parseInt(indexSize))\n                })\n        })\n        .catch(err => reject(err))\n})\nexport const setEsIndexContentSize = (redis, indexName, size) => { redis.set(`size:${indexName}`, size) }\nexport const removeEsIndexContentSize = (redis, indexName) => { redis.del(`size:${indexName}`) }\n\nexport const getEsIndexContentMaxSize = (redis, mongo, indexName) => new Promise((resolve, reject) => {\n    redis.getAsync(`maxsize:${indexName}`)\n        .then(res => {\n            if (res) {\n                resolve(parseInt(res))\n                return\n            }\n\n            return MongoProxy.getUserByIndexName(mongo, indexName)\n                .then(user => {\n                    if (user) {\n                        redis.set(`maxsize:${indexName}`, user.storage_max)\n                        redis.expire(`maxsize:${indexName}`, CONTENT_SETTINGS_EXPIRATION_SECONDS)\n                        resolve(parseInt(user.storage_max))\n                        return\n                    }\n\n                    reject(new Error('User with specified index not found'))\n                })\n        })\n        .catch(err => reject(err))\n})\nexport const setEsIndexContentMaxSize = (redis, indexName, size) => { redis.set(`maxsize:${indexName}`, size) }\nexport const removeEsIndexContentMaxSize = (redis, indexName) => { redis.del(`maxsize:${indexName}`) }\n\nexport const getCurrentCrawlerTask = (redis, crawlerName) => redis.getAsync(`crawlertask:${crawlerName}`)\nexport const setCurrentCrawlerTask = (redis, crawlerName, taskUid) => { redis.set(`crawlertask:${crawlerName}`, taskUid) }\n\nexport const addTag = (redis, elasticSearch, indexName, fileId, tag) => new Promise((resolve, reject) => {\n    EsProxy.indexTag(elasticSearch, indexName, fileId, tag)\n        .then((esResult) =>\n            hasTagsInRedis(redis, indexName)\n                .then(hasTags => {\n                    if (hasTags && esResult.result == 'created') {\n                        return getTagFilesCount(redis, indexName, tag.name, tag.type)\n                            .then(filesCount => {\n                                setTagFilesCount(redis, indexName, tag.name, tag.type, filesCount + 1)\n                            })\n                    }\n                    return Promise.resolve()\n                }))\n        .then(() => getTags(redis, elasticSearch, indexName))\n        .then(tags => resolve(tags))\n        .catch(err => reject(err))\n})\n\nexport const removeTag = (redis, elasticSearch, indexName, fileId, tag) => new Promise((resolve, reject) => {\n    EsProxy.deleteTag(elasticSearch, indexName, fileId, tag.id)\n        .then(() => hasTagsInRedis(redis, indexName))\n        .then(hasTags => {\n            if (hasTags) {\n                return getTagFilesCount(redis, indexName, tag.name, tag.type)\n                    .then(filesCount => {\n                        setTagFilesCount(redis, indexName, tag.name, tag.type, filesCount - 1)\n                    })\n            }\n            return Promise.resolve()\n        })\n        .then(() => getTags(redis, elasticSearch, indexName))\n        .then(tags => resolve(tags))\n        .catch(err => reject(err))\n})\n\nconst transformTagsStat = (redisResp) => !redisResp ? [] : Object.keys(redisResp).map(tagName => ({\n    name: tagName.split(' ')[1],\n    type: tagName.split(' ')[0],\n    filesCount: parseInt(redisResp[tagName])\n})).sort((tagA, tagB) => tagB.filesCount - tagA.filesCount)\n\nconst hasTagsInRedis = (redis, indexName) => new Promise((resolve, reject) => {\n    redis.existsAsync(`tags:${indexName}`)\n        .then(res => resolve(res == 1 ? true : false))\n        .catch(err => reject(err))\n})\n\nconst getTagFilesCount = (redis, indexName, tagName, tagType) => redis.hgetAsync(`tags:${indexName}`, `${tagType} ${tagName}`).then(filesCount => {\n    return !filesCount ? 0 : parseInt(filesCount)\n})\nconst setTagFilesCount = (redis, indexName, tagName, tagType, filesCount) => {\n    if (filesCount == 0) {\n        redis.hdel(`tags:${indexName}`, `${tagType} ${tagName}`)\n        return\n    }\n\n    redis.hset(`tags:${indexName}`, `${tagType} ${tagName}`, filesCount)\n}\n\nexport const getTags = (redis, elasticSearch, indexName) => new Promise((resolve, reject) => {\n    hasTagsInRedis(redis, indexName)\n        .then(hasTags => {\n            if (!hasTags) {\n                return setTagsFromEs(redis, elasticSearch, indexName)\n            }\n            return Promise.resolve()\n        })\n        .then(() => redis.hgetallAsync(`tags:${indexName}`))\n        .then((redisResult) => {\n            resolve(transformTagsStat(redisResult))\n        })\n        .catch(err => reject(err))\n})\n\nconst setTagsFromEs = (redis, elasticSearch, indexName) => new Promise((resolve, reject) => {\n    EsProxy.getTagsStat(elasticSearch, indexName)\n        .then(tags => {\n            if (tags.length == 0) {\n                resolve()\n                return\n            }\n\n            const tagsArray = []\n            let idx = 0\n\n            tags.forEach(tag => {\n                tagsArray[idx] = `${tag.type} ${tag.name}`\n                idx++\n                tagsArray[idx] = tag.filesCount\n                idx++\n            });\n\n            redis.hmset(`tags:${indexName}`, tagsArray, (err, res) => {\n                if (err) {\n                    reject(err)\n                    return\n                }\n                resolve(res)\n            })\n        })\n        .catch(err => reject(err))\n})"]}